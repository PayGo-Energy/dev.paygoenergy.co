{"version":3,"sources":["webpack:///./src/pages/blog/2019-06-20-sailsjs-transactions-and-exits/index.js","webpack:///./src/pages/blog/2019-06-20-sailsjs-transactions-and-exits/post.md"],"names":["Layout","title","Markdown","source"],"mappings":"mJAOe,4BACb,kBAACA,EAAA,EAAD,CAAQC,MAAM,kCACZ,kBAACC,EAAA,EAAD,CAAUC,OCTC","file":"component---src-pages-blog-2019-06-20-sailsjs-transactions-and-exits-index-js-3bb97025a4fd8e2f793f.js","sourcesContent":["import React from 'react';\n\nimport Layout from '../../../Layout';\nimport Markdown from '../../../Markdown';\n\nimport post from './post.md';\n\nexport default () => (\n  <Layout title=\"SailsJS transactions and exits\">\n    <Markdown source={post}/>\n  </Layout>\n);\n","export default \"[Sails.js Transaction Behaviour](/blog/2019-06-20-sailsjs-transactions-and-exits)\\n=============================\\n\\nSails.js [supports transactions](https://sailsjs.com/documentation/reference/waterline-orm/datastores/transaction) when using the [`sails-postgresql`](https://github.com/balderdashy/sails-postgresql) and [`sails-mysql`](https://github.com/balderdashy/sails-mysql) datastore adapters.\\n\\nI only have experience with `sails-postgresql`, so unless otherwise mentioned, code below is in reference to that.\\n\\nAt [PayGo](https://dev.paygoenergy.co) we've had a few surprises about how sails transactions act from within controllers.  In hindsight some of these are obvious, but others are a little more subtle.\\n\\n# Rule: updating a row locks it until the transaction completes\\n\\nIf you have two competing transactions updating the same row, one will be blocked until the other has completed.\\n\\n## Example\\n\\nYou have a simple model:\\n\\n```\\n// api/models/Thing.js\\nmodule.exports = {\\n  attributes: {\\n    ...\\n    lastUpdatedBy: { type:'string' },\\n    ...\\n  },\\n};\\n```\\n\\nAnd two controllers:\\n\\n```\\n// api/controllers/quick.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          await Thing\\n              .update(1)\\n              .set({ lastUpdatedBy:'quick' });\\n        });\\n  },\\n};\\n```\\n```\\n// api/controllers/slow.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          await Thing\\n              .update(1)\\n              .set({ lastUpdatedBy:'slow' });\\n          await sleep(10000);\\n        });\\n  },\\n};\\n\\nconst sleep = millis => new Promise(resolve => setTimeout(resolve, millis));\\n```\\nIf you now call:\\n\\n```\\ntime curl http://localhost:1337/slow &\\nsleep 1 && time curl http://localhost:1337/quick\\n```\\n\\nYou will see that the call to `/quick` waits until the call to `/slow` has completed before it returns.\\n\\n# Rule: never update a row without locking, unless your update is atomic\\n\\nModifying our slow/quick example from above so that the slow controller now sleeps _before_ updating the db, using the standard sails locking strategy:\\n\\n```\\n// api/models/Thing.js\\nmodule.exports = {\\n  attributes: {\\n    ...\\n    counter: { type:'number', columnType:'integer' },\\n    ...\\n  },\\n};\\n```\\n```\\n// api/controllers/current.js\\nmodule.exports = {\\n  fn: async function() {\\n    const t = await Thing.findOne(1);\\n    return exits.success(t.counter);\\n  },\\n};\\n```\\n```\\n// api/controllers/quick.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          const t = await Thing.findOne(1).usingConnection(db);\\n          await Thing\\n              .update(t.id)\\n              .set({ counter:t.counter+10 })\\n              .usingConnection(db);\\n        });\\n  },\\n};\\n```\\n```\\n// api/controllers/slow.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          const t = await Thing.findOne(1).usingConnection(db);\\n          await sleep(10000);\\n          await Thing\\n              .update(t.id)\\n              .set({ counter:t.counter+3 })\\n              .usingConnection(db);\\n        });\\n  },\\n};\\n\\nconst sleep = millis => new Promise(resolve => setTimeout(resolve, millis));\\n```\\n\\nAssuming an initial value for `t.counter` of zero, if you now call:\\n\\n```\\ncurl http://localhost:1337/current\\ncurl -q http://localhost:1337/slow &\\nsleep 1\\ncurl -q http://localhost:1337/quick\\ncurl -q http://localhost:1337/current\\nsleep 10\\ncurl http://localhost:1337/current\\n```\\n\\nYou will see:\\n\\n```\\n0\\n10\\n3\\n```\\n\\n## Problem\\n\\nAlthough both controllers are reading `Thing #1`, incrementing its counter, and writing it within a transaction, their transactions overlap and cause inconsistent values to be written to the database.\\n\\nInterestingly, in this case there is actually no value to calling `findOne()` within the transaction - the `usingConnection(db)` appears to do nothing.\\n\\n## Solution 1: single SQL queries\\n\\nTo achieve consistent updates for these rows, one option is to use proper SQL to perform our updates.  The `quick` and `slow` controllers can be rewritten to increment the `counter` column in a single query:\\n\\n```\\n// api/controllers/quick.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .sendNativeQuery('UPDATE Thing SET counter=counter+10 WHERE id=$1', [ 1 ]);\\n  },\\n};\\n```\\n```\\n// api/controllers/slow.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sleep(10000);\\n    await sails\\n        .getDatastore()\\n        .sendNativeQuery('UPDATE Thing SET counter=counter+3 WHERE id=$1', [ 1 ]);\\n  },\\n};\\n\\nconst sleep = millis => new Promise(resolve => setTimeout(resolve, millis));\\n```\\n\\n## Solution 2: optimistic locking\\n\\nOptimistic locking is a lock that is only checked at write-time.  If there have been changes to a row between reading and writing, the write operation fails.\\n\\nNote that if updating more than one row in a single operation, you should still be using transactions.  At this point you are implicitly using both optimistic _and_ pessimistic locking.\\n\\n### With implicit versioning\\n\\nOptimistic locking can be achieved by including the full details of the selected object when requesting an update, e.g.:\\n\\n```\\nThing t = await Thing.find(1);\\nconst updatedRowCount = await Thing\\n    .update(t)\\n    .set({ some_property:'new-value' });\\nif(!updatedRowCount) throw new Error('Update failed for Thing #1');\\n```\\n\\n### With explicit versioning\\n\\nAnother approach is to manually track your own `version` column on each database model, and check it whenever doing an update:\\n\\n```\\n// api/models/Thing.js\\nmodule.exports = {\\n  attributes: {\\n    ...\\n    version: { type:'number', columnType:'integer' },\\n    ...\\n  },\\n};\\n```\\n```\\n// api/controllers/quick.js\\nconst optimisticUpdate = require('../../utils/optimistic-update');\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          const t = await Thing.findOne(1).usingConnection(db);\\n          await optimisticUpdate(db, Thing, t, { counter:t.counter+10 });\\n        });\\n  },\\n};\\n```\\n```\\n// api/controllers/slow.js\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          const t = await Thing.findOne(1).usingConnection(db);\\n          await sleep(10000);\\n          await optimisticUpdate(db, Thing, t, { counter:t.counter+3 });\\n        });\\n  },\\n};\\n...\\n```\\n```\\n// utils/optimistic-update.js\\nmodule.exports = async function(db, Model, e, update) {\\n  const updated = Model\\n      .updateOne({ id:e.id, version:e.version })\\n      .set(update)\\n      .usingConnection(db);\\n\\n  if(!updated) throw new Error(`${Model.globalId}#${e.id} has changed version since last read (expected v${e.version})!`);\\n\\n  return updated;\\n};\\n...\\n```\\n\\nAs above, in this case there is no value to calling `findOne()` within the transaction - the `usingConnection(db)` appears to do nothing.\\n\\n`optimisticUpdate()` could also be added to each model's API, e.g. in `config/bootstrap.js`:\\n\\n```\\n// config/bootstrap.js\\nmodule.exports = {\\n  ...\\n  Object.values(sails.models).forEach(addOptimisticUpdate);\\n  ...\\n};\\n\\nfunction addOptimisticUpdate(Model) {\\n  Model.optimisticUpdate = async (db, e, update) => {\\n    const updated = await Model\\n        .updateOne({ id:e.id, version:e.version })\\n        .set(update)\\n        .usingConnection(db);\\n\\n    if(!updated) throw new Error(`${Model.globalId}#${e.id} has changed version since last read (expected v${e.version})!`);\\n\\n    return updated;\\n  };\\n}\\n```\\n\\n## Solution 3: pessimistic locking\\n\\nThis option does not require changes to the data model.  It leaves lock handling to PostgreSQL, which is convenient from an application developer's point of view.  However, there may be performance implications relating to keeping database connections open for longer, and transactions can still fail when competing transactions attempt to make concurrent updates to the same database rows.  In the following implementation, it is also more error-prone if you pass complicated criteria to `find()` or `findOne()`, or non-standard mappings between column names and sails `attributes`.  It takes advantage of PostgreSQL's [`SELECT ... FOR UPDATE` syntax](https://www.postgresql.org/docs/9.5/sql-select.html).\\n\\n```\\n// api/controllers/quick.js\\nconst findOneForUpdate = require('../../utils/find-one-for-update');\\n\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          const t = await findOneForUpdate(db, Thing, 1);\\n          await Thing\\n              .update(t.id)\\n              .set({ counter:t.counter+10 })\\n              .usingConnection(db);\\n        });\\n  },\\n};\\n```\\n```\\n// api/controllers/slow.js\\nconst findOneForUpdate = require('../../utils/find-one-for-update');\\n\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          const t = await findOneForUpdate(db, Thing, 1);\\n          await sleep(10000);\\n          await Thing\\n              .update(t.id)\\n              .set({ counter:t.counter+10 })\\n              .usingConnection(db);\\n        });\\n  },\\n};\\n...\\n```\\n```\\n// utils/find-one-for-update.js\\nmodule.exports = async function(db, Model, id) {\\n  return sails\\n      .getDatastore()\\n      .sendNativeQuery(`SELECT * FROM ${Model.tableName} WHERE id=$1 FOR UPDATE`, [ id ])\\n      .usingConnection(db);\\n};\\n...\\n```\\n\\n# Rule: never reference `exits` from within `transaction(...)`\\n\\n## Example: `exits.success()`\\n\\n### Bad code \\n\\n```\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n      .getDatastore()\\n      .transaction(async db => {\\n        doSomeTransactionalStuff(db);\\n        return exits.success();\\n      });\\n  },\\n};\\n```\\n\\n### Good code\\n\\n```\\nmodule.exports = {\\n  fn: async function(inputs, exits) {\\n    await sails\\n      .getDatastore()\\n      .transaction(async db => {\\n        doSomeTransactionalStuff(db);\\n      });\\n\\n    return exits.success();\\n  },\\n};\\n```\\n\\n### Explanation\\n\\nWhen `exits.success()` is called, the HTTP Status code `200` is written to the response stream.  After this has been written, it cannot be changed to an error code.  However, in the first example, `exits.success()` is called _before the transaction has been committed to the database_.  This means that although there were no `Error`s thrown by `doSomeTransactionalStuff()`, there is still a chance that the transaction commit could fail in PostgreSQL.  Some reasons this could fail include:\\n\\n* violation of a database-level constraint, e.g.uniqueness\\n* failure/timeout of the db connection\\n\\nBecause `exits.success()` has already been called, there is no way to notify the client that there was a problem committing the transaction.\\n\\nMore insidious, if the transaction _succeeds_, a race condition is introduced: the client may process the 200 response before the database write has completed.  We've seen integration tests fail intermittently because of this.\\n\\nTherefore, any call to `exits.*()` or `this.res.status(...)` must be made _after_ a transaction has been committed.\\n\\nIf the transaction fails, an `Error` will be thrown.  In the first example, this will provoke sails to report:\\n\\n```\\nWARNING: Something seems to be wrong with this function.\\nIt is trying to signal that it has finished AGAIN, after\\nalready resolving/rejecting once.\\n(silently ignoring this...)\\n```\\n\\nIn the good code above, the `Error` will be thrown _before_ the call to `exits.success()`, and a `500` error returned to the client.\\n\\n## Example: `exits.myError()`\\n\\n### Bad code\\n\\n```\\nmodule.exports = {\\n  exits: {\\n    myError: { statusCode:500 },\\n  },\\n  fn: async function(inputs, exits) {\\n    await sails\\n      .getDatastore()\\n      .transaction(async db => {\\n        await Thing\\n            .update({ some_property:'some_value' })\\n            .set({ other_property:false });\\n\\n        const ok = await isSomeConstraintSatisfied(inputs);\\n        if(!ok) {\\n          return exits.myError();\\n        }\\n      });\\n\\n    return exits.success();\\n  },\\n};\\n```\\n\\n### Good code\\n\\n```\\nmodule.exports = {\\n  exits: {\\n    myError: { statusCode:500 },\\n  },\\n  fn: async function(inputs, exits) {\\n    try {\\n      await sails\\n        .getDatastore()\\n        .transaction(async db => {\\n          await Thing\\n              .update({ some_property:'some_value' })\\n              .set({ other_property:false });\\n\\n          const ok = await isSomeConstraintSatisfied(inputs);\\n          if(!ok) {\\n            throw new Error();\\n          }\\n        });\\n\\n      return exits.success();\\n    } catch(e) {\\n      return exits.myError();\\n    }\\n  },\\n};\\n```\\n\\n### Explanation\\n\\nThere are two problems in the bad code above - the `return` within the transaction:\\n\\n1. actually returns to the parent `fn`, which then continues executing.  Therefore both `exits.myError()` _and_ `exits.success()` are called.\\n2. allows the transaction to complete cleanly, and therefore `waterline` will attempt to commit it to the database.  This means that, perhaps counterintuitively, if we return `exits.myError()`, the database update to `Thing` will still be committed to the database.\\n\\nIn the second example, if `ok` is `false`, an `Error` is thrown.  This causes the transaction to be rolled back, before finally calling `exits.myError()`, which will return a status `500` to the client.\\n\\n# Rule: `.intercept()` actually works!\\n\\nThis surprised me, as it looks like it should also suffer from the two-writes bug described above (\\\"`It is trying to signal that it has finished AGAIN`\\\"):\\n\\n```\\nmodule.exports = {\\n  exits: {\\n    badly: { statusCode:567 },\\n  },\\n\\n  fn: async function(inputs, exits) {\\n    await sails\\n      .getDatastore()\\n      .transaction(async db => {\\n        await Thing\\n            .create({ id:1 })\\n            .intercept('E_UNIQUE', 'badly')\\n            .usingConnection(db);\\n      });\\n\\n    return exits.success();\\n  },\\n};\\n```\\n\\nAs intended, although perhaps not expected, this will return an HTTP status code of `567`, _without_ logging a `WARNING` 🤔\\n\\n---\\n\\n# Conclusion\\n\\nTransactions are important, but complicated.  `exits` are complicated, but perhaps not important.  🤷\\n\";"],"sourceRoot":""}